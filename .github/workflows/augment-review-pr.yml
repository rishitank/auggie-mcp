name: Pull Request Review

on:
  pull_request:
    types: [opened, ready_for_review, synchronize]

permissions:
  contents: read
  pull-requests: write

jobs:
  review-pr:
    name: Pull Request Review
    runs-on:
      - ubuntu-latest
    if: github.event.pull_request.head.repo.full_name == github.event.pull_request.base.repo.full_name && github.event.pull_request.draft == false
    steps:
      - name: Generate PR Review
        uses: augmentcode/review-pr@v0
        with:
          augment_session_auth: ${{ secrets.AUGMENT_SESSION_AUTH }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          pull_number: ${{ github.event.pull_request.number }}
          repo_name: ${{ github.repository }}
      - name: Auto-resolve addressed suggestions
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const number = pr.number;
            const { owner, repo } = context.repo;
            const gql = (q, v) => github.graphql(q, v);

            const listThreadsQuery = `
              query($owner: String!, $repo: String!, $number: Int!, $after: String) {
                repository(owner: $owner, name: $repo) {
                  pullRequest(number: $number) {
                    headRefOid
                    reviewThreads(first: 100, after: $after) {
                      nodes { id isResolved comments(first: 1) { nodes { body path } } }
                      pageInfo { hasNextPage endCursor }
                    }
                  }
                }
              }
            `;
            const resolveThreadMutation = `
              mutation($threadId: ID!) { resolveReviewThread(input: { threadId: $threadId }) { thread { id isResolved } } }
            `;
            const getFileAtHead = async (path) => {
              const headSha = context.payload.pull_request.head.sha;
              const { data } = await github.request('GET /repos/{owner}/{repo}/contents/{path}', { owner, repo, path, ref: headSha });
              const buf = Buffer.from(data.content, data.encoding || 'base64');
              return buf.toString('utf8');
            };
            const suggestionRegex = /```suggestion\s*[\r\n]+([\s\S]*?)```/m;

            let threads = [];
            let after = null;
            do {
              const res = await gql(listThreadsQuery, { owner, repo, number, after });
              const page = res.repository.pullRequest.reviewThreads;
              threads.push(...page.nodes);
            const matchesSuggestion = (file, suggestion) => {
              if (!suggestion || suggestion.length <= 10) return false;
              const norm = suggestion.replace(/\r\n/g, '\n');
              const lines = norm.split('\n').filter(l => l.trim() !== '');
              if (lines.length < 2) return false; // require multi-line to avoid trivial matches
              const escape = (s) => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
              const escaped = lines.map(escape);
              const pattern = escaped.map((l, i) => (i === 0 ? l : '\\s*' + l)).join('\\r?\\n');
              const re = new RegExp(pattern, 'm');
              if (re.test(file)) return true;
              // Fallback exact check
              return file.includes(norm);
            };

              after = page.pageInfo.hasNextPage ? page.pageInfo.endCursor : null;
            } while (after);

            let resolved = 0;
            for (const t of threads) {
              if (t.isResolved) continue;
              const c = t.comments.nodes[0];
              if (!c || !c.body) continue;
              const m = c.body.match(suggestionRegex);
              if (!m) continue; // only auto-resolve suggestion-type comments
              const suggestion = m[1].trim();
              if (!suggestion) continue;
              try {
                const file = await getFileAtHead(c.path);
                if (matchesSuggestion(file, suggestion)) {
                  await gql(resolveThreadMutation, { threadId: t.id });
                  resolved++;
                }
              } catch (e) {
                core.warning(`Skip thread ${t.id} for path ${c.path}: ${e.message}`);
              }
            }
            core.info(`Auto-resolved ${resolved} review thread(s).`);

